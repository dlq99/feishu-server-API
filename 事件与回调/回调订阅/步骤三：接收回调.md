# æ­¥éª¤ä¸‰ï¼šæ¥æ”¶å›è°ƒ

æœ¬æ–‡ä»‹ç»ä¸åŒå›è°ƒè®¢é˜…æ–¹å¼å¦‚ä½•æ¥æ”¶å›è°ƒã€‚

## ä½¿ç”¨é•¿è¿æ¥æ–¹å¼æ¥æ”¶å›è°ƒ

é•¿è¿æ¥æ–¹å¼å†…å°è£…äº†é‰´æƒé€»è¾‘ï¼Œåªåœ¨å»ºè¿æ—¶è¿›è¡Œé‰´æƒï¼Œåç»­å›è°ƒæ¨é€å‡ä¸ºæ˜æ–‡æ•°æ®ï¼Œæ— éœ€å†å¤„ç†è§£å¯†å’ŒéªŒç­¾é€»è¾‘ã€‚å› æ­¤ï¼Œå¦‚æœä½ é…ç½®çš„å›è°ƒè®¢é˜…æ–¹å¼ä¸º **ä½¿ç”¨é•¿è¿æ¥æ¥æ”¶å›è°ƒ**ï¼Œåªéœ€ä¿æŒæœ¬åœ°æœåŠ¡å™¨å»ºç«‹é•¿è¿æ¥ï¼Œåœ¨å›è°ƒè§¦å‘æ—¶å³å¯æ¥æ”¶åˆ°æ¥è‡ªé£ä¹¦å¼€æ”¾å¹³å°çš„å›è°ƒæ¶ˆæ¯è¯·æ±‚ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ¥æ”¶åˆ° `card.action.trigger` å›è°ƒï¼Œå³å¡ç‰‡å›ä¼ äº¤äº’å›è°ƒã€‚


![image.png](//sf3-cn.feishucdn.com/obj/open-platform-opendoc/4b8ab6eadce1922263608aa43260fcbc_e5Roy7fVd7.png?height=310&lazyload=true&maxWidth=650&width=2852)

ä½ çš„ä¸šåŠ¡æœåŠ¡å™¨æ¥æ”¶å›è°ƒè¯·æ±‚åï¼Œéœ€è¦åœ¨ 3 ç§’å†…å“åº”å›è°ƒï¼Œä»¥å®Œæˆé£ä¹¦å®¢æˆ·ç«¯ï¼ˆå‰ç«¯ï¼‰çš„äº¤äº’è¡Œä¸ºã€‚ç›®å‰éœ€è¦è®¢é˜…å›è°ƒçš„åŠŸèƒ½ä»¥åŠå¯¹åº”çš„å›è°ƒç»“æ„ã€ä½¿ç”¨æ–¹å¼ç­‰è¯´æ˜å‚è§ä¸‹è¡¨ã€‚

| åŠŸèƒ½ | å›è°ƒç»“æ„ | ç›¸å…³æ–‡æ¡£ |
| --- | --- | --- |
| é“¾æ¥é¢„è§ˆ | å®ç°é“¾æ¥é¢„è§ˆåŠŸèƒ½å¿…é¡»è®¢é˜… æ‹‰å–é“¾æ¥é¢„è§ˆæ•°æ® å›è°ƒï¼Œè¯¥å›è°ƒå¯¹åº”çš„å›è°ƒå‚æ•°ã€å“åº”å‚æ•°è¯´æ˜ï¼Œå¯å‚è§æ‹‰å–é“¾æ¥é¢„è§ˆæ•°æ®ã€‚ | äº†è§£é“¾æ¥é¢„è§ˆåŠŸèƒ½ï¼Œä»¥åŠå¦‚ä½•é…ç½®é“¾æ¥é¢„è§ˆï¼Œå‚è§é“¾æ¥é¢„è§ˆå¼€å‘æŒ‡å—ã€‚ |
| é£ä¹¦å¡ç‰‡ | å¦‚æœä½ æ„å»ºçš„é£ä¹¦å¡ç‰‡å¯é€šè¿‡äº¤äº’ç»„ä»¶å®Œæˆä¸šåŠ¡å¤„ç†ï¼Œåˆ™éœ€è¦è®¢é˜… å¡ç‰‡å›ä¼ äº¤äº’ å›è°ƒï¼Œè¯¥å›è°ƒå¯¹åº”çš„å›è°ƒå‚æ•°ã€å“åº”å‚æ•°è¯´æ˜ï¼Œå¯å‚è§å¡ç‰‡å›ä¼ äº¤äº’ã€‚ | - äº†è§£é£ä¹¦å¡ç‰‡åŠŸèƒ½ï¼Œå‚è§é£ä¹¦å¡ç‰‡æ¦‚è¿°ã€‚<br>- äº†è§£é£ä¹¦å¡ç‰‡è¯·æ±‚å›è°ƒå®ç°æµç¨‹ï¼Œå‚è§é…ç½®å¡ç‰‡äº¤äº’ã€‚ |



## é€šè¿‡å¼€å‘è€…æœåŠ¡å™¨æ¥æ”¶å›è°ƒ

å¦‚æœä½ é…ç½®çš„å›è°ƒè®¢é˜…æ–¹å¼ä¸º **å°†å›è°ƒå‘é€è‡³å¼€å‘è€…æœåŠ¡å™¨**ï¼Œåœ¨æ¥æ”¶åˆ°é£ä¹¦å¼€æ”¾å¹³å°æ¨é€çš„å›è°ƒåï¼Œå¯ä»¥è¿›è¡Œå®‰å…¨æ ¡éªŒã€‚å¦‚æœæ˜¯åŠ å¯†å›è°ƒï¼Œéœ€è¦å…ˆè§£å¯†å›è°ƒï¼Œå†è§£æå›è°ƒè¯¦æƒ…ã€‚

### æµç¨‹æ¦‚è¿°

å½“é£ä¹¦æœåŠ¡å™¨æ¨é€å›è°ƒè‡³è¯·æ±‚åœ°å€åï¼Œå¯¹åº”çš„ä¸šåŠ¡æœåŠ¡å™¨éœ€è¦æ¥æ”¶å›è°ƒè¯·æ±‚ï¼Œå¹¶åœ¨ 3 ç§’å†…å®Œæˆä¸šåŠ¡å¤„ç†ã€è¿”å›å“åº”ç»“æœã€‚åœ¨è¯¥è¿‡ç¨‹ä¸­ï¼Œä½ éœ€è¦æ ¹æ®å®é™…é…ç½®æƒ…å†µï¼Œå®Œæˆä»¥ä¸‹æ“ä½œã€‚



> **ğŸ“ æ³¨æ„**
> å›è°ƒæ˜¯åŒæ­¥æ“ä½œï¼Œä¸æä¾›è¡¥æ¨æœºåˆ¶ã€‚å¦‚æœä½ çš„ä¸šåŠ¡æœåŠ¡å™¨è¶…æ—¶æœªå“åº”ï¼Œåˆ™ç³»ç»Ÿä¼šåˆ¤æ–­å›è°ƒå¤±è´¥ï¼Œå¹¶åœ¨é£ä¹¦å®¢æˆ·ç«¯å†…å±•ç¤ºæŠ¥é”™ä¿¡æ¯ã€‚



| æ“ä½œ | æ˜¯å¦å¿…é¡» | æè¿° |
| --- | --- | --- |
| [å®‰å…¨æ ¡éªŒ](#å®‰å…¨æ ¡éªŒ) | å¦ | å®‰å…¨æ ¡éªŒç”¨äºç¡®è®¤ä¸šåŠ¡æœåŠ¡å™¨æ¥æ”¶åˆ°çš„è¯·æ±‚æ¥è‡ªé£ä¹¦å¼€æ”¾å¹³å°ï¼Œè€Œä¸æ˜¯ä¼ªé€ çš„é£é™©è¯·æ±‚ã€‚ |
| [å›è°ƒè§£å¯†](#å›è°ƒè§£å¯†) | å¦ | å»ºè®®ä¸ºåº”ç”¨é…ç½® Encrypt Keyï¼Œé…ç½®åæ¨é€çš„å›è°ƒè¯·æ±‚ä¸ºåŠ å¯†æ•°æ®ï¼Œèƒ½å¤Ÿç¡®ä¿è¯·æ±‚æ•°æ®å®‰å…¨æ€§ã€‚ç›¸åº”çš„ï¼Œä¸šåŠ¡æœåŠ¡å™¨æ”¶åˆ°è¯·æ±‚åï¼Œéœ€è¦è¿›è¡Œè§£å¯†ï¼Œæ‰å¯ä»¥è·å–åˆ°çœŸå®çš„å›è°ƒæ•°æ®ã€‚ |
| [å“åº”å›è°ƒè¯·æ±‚](#å“åº”å›è°ƒè¯·æ±‚) | æ˜¯ | ä¸šåŠ¡æœåŠ¡å™¨åœ¨æ”¶åˆ°å›è°ƒè¯·æ±‚åï¼Œå¿…é¡»è¿”å›å“åº”ç»“æœï¼Œå¦åˆ™ä¼šè¢«ç³»ç»Ÿåˆ¤æ–­ä¸ºå›è°ƒå¤±è´¥ã€‚ |




### å®‰å…¨æ ¡éªŒ

å½“ä½ çš„ä¸šåŠ¡æœåŠ¡å™¨æ¥æ”¶åˆ°æ¥è‡ªé£ä¹¦å¼€æ”¾å¹³å°æ¨é€çš„å›è°ƒæ—¶ï¼Œä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ç¡®ä¿è¯·æ±‚æ¥è‡ªé£ä¹¦å¼€æ”¾å¹³å°ã€‚



> **âš ï¸ è­¦å‘Š**
> æœ¬æ–‡æä¾›çš„å®‰å…¨æ ¡éªŒä¸é€‚ç”¨äº  **æ¶ˆæ¯å¡ç‰‡å›ä¼ äº¤äº’ï¼ˆæ—§ï¼‰**ï¼ˆcard.action.trigger_v1ï¼‰å›è°ƒã€‚å¦‚æœä½ éœ€è¦ä¸º **æ¶ˆæ¯å¡ç‰‡å›ä¼ äº¤äº’ï¼ˆæ—§ï¼‰** é…ç½®å®‰å…¨æ ¡éªŒï¼Œåˆ™éœ€è¦å‚è€ƒé…ç½®å›è°ƒè¯·æ±‚åœ°å€ã€‚



#### æ–¹å¼ä¸€ï¼šVerification Token æ ¡éªŒ

é£ä¹¦åº”ç”¨é»˜è®¤é…ç½®äº† Verification Tokenï¼Œä½ å¯ä»¥åœ¨ä¸šåŠ¡æœåŠ¡å™¨å†…æ¥æ”¶å›è°ƒè¯·æ±‚ï¼Œå¹¶åœ¨è¯·æ±‚ä½“ä¸­è·å– Verification Token å€¼ï¼Œå°†è¯¥å€¼ä¸é£ä¹¦åº”ç”¨å†…çš„ Verification Token å€¼è¿›è¡Œæ¯”å¯¹ï¼Œå–å€¼ç›¸åŒåˆ™è¯´æ˜è¯¥è¯·æ±‚æ¥è‡ªé£ä¹¦å¼€æ”¾å¹³å°çš„æŒ‡å®šåº”ç”¨ã€‚



> **ğŸ“ æ³¨æ„**
> - è¯¥æ–¹å¼ç›¸å¯¹æ¥è¯´æ“ä½œç®€å•ï¼Œä½†å®‰å…¨æ€§è¾ƒä½ã€‚ä¾‹å¦‚ï¼Œæ˜æ–‡ä¼ è¾“ Verification Token å€¼ä¼šæœ‰æ•°æ®æ³„éœ²é£é™©ã€‚
> - å¦‚æœåº”ç”¨é…ç½®äº† Encrypt Key åŠ å¯†ç­–ç•¥ï¼Œåˆ™ä½ éœ€è¦åœ¨ä¸šåŠ¡æœåŠ¡å™¨å†…å…ˆè¿›è¡Œè§£å¯†ï¼Œæ‰èƒ½è·å–åˆ° Verification Token å€¼ã€‚è§£å¯†æ“ä½œå‚è§ä¸‹æ–‡çš„ **å›è°ƒè§£å¯†** ç« èŠ‚ã€‚



#### æ–¹å¼äºŒï¼šç­¾åæ ¡éªŒ

å¦‚æœä½ åœ¨é£ä¹¦åº”ç”¨å†…é…ç½®äº† Encrypt Key åŠ å¯†ç­–ç•¥ï¼Œåˆ™ä¸šåŠ¡æœåŠ¡å™¨æ¥æ”¶åˆ°å›è°ƒè¯·æ±‚åï¼Œæ— éœ€è¿›è¡Œè§£å¯†æ“ä½œï¼Œå¯ç›´æ¥å®Œæˆç­¾åæ ¡éªŒã€‚



> **ğŸ“ æ³¨æ„**
> è¯¥æ–¹å¼ç›¸å¯¹æ¥è¯´æ“ä½œè¾ƒå¤æ‚ï¼Œä½†å®‰å…¨æ€§é«˜ã€‚



**æ ¡éªŒæµç¨‹**

1. è¿›å…¥[å¼€å‘è€…åå°](https://open.feishu.cn/app)çš„æŒ‡å®šåº”ç”¨è¯¦æƒ…é¡µã€‚
2. åœ¨å·¦ä¾§å¯¼èˆªæ é€‰æ‹© **å¼€å‘é…ç½®** > **äº‹ä»¶ä¸å›è°ƒ**ï¼Œå¹¶é€‰æ‹© **åŠ å¯†ç­–ç•¥**ã€‚
3. åœ¨ **åŠ å¯†ç­–ç•¥** é¡µç­¾ï¼Œè·å–å·²é…ç½®çš„ **Encrypt Key**ã€‚
    
    ![](//sf3-cn.feishucdn.com/obj/open-platform-opendoc/72970646575802f2f972ed3a4e04d0bf_gTpSb5FBVl.png?height=626&lazyload=true&maxWidth=600&width=1556)

4. åœ¨æœ¬åœ°çš„ä¸šåŠ¡æœåŠ¡å™¨å†…ï¼Œæ ¡éªŒè¯·æ±‚æ¥æºã€‚
    
    1. å°†è¯·æ±‚å¤´ `X-Lark-Request-Timestamp`ã€`X-Lark-Request-Nonce` ä¸ `encrypt_key` æ‹¼æ¥åï¼ŒæŒ‰ç…§ `encode('utf-8')` ç¼–ç å¾—åˆ° `byte[] b1`ï¼Œå†æ‹¼æ¥ä¸Šè¯·æ±‚çš„åŸå§‹ bodyï¼Œå¾—åˆ°ä¸€ä¸ª `byte[] b`ã€‚
    2. å°† `b` ç”¨ sha256 ç®—æ³•å¾—åˆ°å­—ç¬¦ä¸² `s`ï¼Œ æ ¡éªŒ `s` æ˜¯å¦å’Œè¯·æ±‚å¤´ `X-Lark-Signature` ä¸€è‡´ã€‚

**ç¤ºä¾‹ä»£ç **

ä»¥ä¸‹æä¾›å„å¼€å‘è¯­è¨€çš„ç­¾åæ ¡éªŒç¤ºä¾‹ä»£ç ï¼Œå…¶ä¸­åŒ…æ‹¬çš„å‚æ•°è¯´æ˜å¦‚ä¸‹è¡¨æ‰€ç¤ºã€‚
| **å‚æ•°**        | **è¯´æ˜**                              |
| ------------- | ----------------------------------- |
| `timestamp`   | å¯¹åº”è¯·æ±‚å¤´ä¸­çš„ `X-Lark-Request-Timestamp` |
| `nonce`       | å¯¹åº”è¯·æ±‚å¤´ä¸­çš„ `X-Lark-Request-Nonce`   |
| `encrypt_key` | ä»å¼€å‘è€…åå°è·å–åˆ°çš„åº”ç”¨ Encrypt Key          |
- **Python 3**
    
```python
import hashlib
bytes_b1 = (timestamp + nonce + encrypt_key).encode('utf-8')
bytes_b = bytes_b1 + body
h = hashlib.sha256(bytes_b)
signature = h.hexdigest()

# check if request headers['X-Lark-Signature'] equals to signature
```

- **Java**

```java
import org.apache.commons.codec.binary.Hex;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
class Main {
  public String calculateSignature(String timestamp, String nonce, String encryptKey, String bodyString) throws NoSuchAlgorithmException {
	  StringBuilder content = new StringBuilder();
	  content.append(timestamp).append(nonce).append(encryptKey).append(bodyString);
	  MessageDigest alg = MessageDigest.getInstance("SHA-256");
	  String sign = Hex.encodeHexString(alg.digest(content.toString().getBytes()));
	  return sign;
  }
}
```

- **Golang**

```
import (
   "crypto/sha256"
   "fmt"
)
func calculateSignature(timestamp, nonce, encryptKey, bodystring string) string {
   var b strings.Builder
   b.WriteString(timestamp)
   b.WriteString(nonce)
   b.WriteString(encryptKey)
   b.WriteString(bodystring) //bodystring æŒ‡æ•´ä¸ªè¯·æ±‚ä½“ï¼Œä¸è¦åœ¨ååºåˆ—åŒ–åå†è®¡ç®—
   bs := []byte(b.String())
   h := sha256.New()
   h.Write(bs)
   bs = h.Sum(nil)
   sig := fmt.Sprintf("%x", bs)
   return sig
}
```

- **node.js**

```javascript
var crypto = require('crypto');
function calculateSignature(timestamp, nonce, encryptKey, body) {
		const content = timestamp + nonce + encryptKey + body
		const sign = crypto.createHash('sha256').update(content).digest('hex');
		return sign
}
```

- **C#**

```c#
using System.Security.Cryptography;
public static string calculateSignature(string timestamp, string nonce, string encryptKey, string body) {
		StringBuilder content = new StringBuilder();
		content.Append(timestamp);
		content.Append(nonce);
		content.Append(encryptKey);
		content.Append(body);
		SHA256 sha256 = new SHA256CryptoServiceProvider();  
		byte[] bytes_out = sha256.ComputeHash(Encoding.UTF8.GetBytes(content.ToString()));  
		string result = BitConverter.ToString(bytes_out);  
		result = result.Replace("-", "");  
		return result;  
}
```

- **PHP**

```
<?php
$encrypt_key = "";  // å¼€æ”¾å¹³å°åå°çš„ Encrypt Key
$timestamp = "";
$nonce = "";
$body = ""; // æŒ‡æ•´ä¸ªè¯·æ±‚ä½“ï¼Œä¸è¦åœ¨ååºåˆ—åŒ–åå†è®¡ç®—
$signature = hash("sha256", $timestamp . $nonce . $encrypt_key . $body);
// check if request headers['X-Lark-Signature'] equals to signature
```

### å›è°ƒè§£å¯†

å¦‚æœä½ åœ¨é£ä¹¦åº”ç”¨å†…é…ç½®äº† Encrypt Key åŠ å¯†ç­–ç•¥ï¼Œåˆ™ä¸šåŠ¡æœåŠ¡å™¨æ¥æ”¶åˆ°å›è°ƒè¯·æ±‚åï¼Œéœ€è¦è¿›è¡Œå›è°ƒè§£å¯†ã€‚



> **âš ï¸ è­¦å‘Š**
> å›è°ƒè§£å¯†æ“ä½œä¸é€‚ç”¨äº **æ¶ˆæ¯å¡ç‰‡å›ä¼ äº¤äº’ï¼ˆæ—§ï¼‰**ï¼ˆcard.action.trigger_v1ï¼‰å›è°ƒï¼Œå› æ­¤ä½¿ç”¨ **æ¶ˆæ¯å¡ç‰‡å›ä¼ äº¤äº’ï¼ˆæ—§ï¼‰** å›è°ƒæ—¶å¯å¿½ç•¥æœ¬ç« èŠ‚æ“ä½œã€‚





#### è§£å¯†ç¤ºä¾‹ä»£ç 

ä½ å¯ä»¥å‚è€ƒä»¥ä¸‹å„å¼€å‘è¯­è¨€çš„ç¤ºä¾‹ä»£ç ï¼Œè§£å¯†å›è°ƒæ•°æ®ã€‚

- **Python 3**



> **ğŸ“ æ³¨æ„**
> è¯·å…ˆæ‰§è¡Œ `pip install pycryptodome` ä»¥æ”¯æŒå¼•å…¥ AES æ–¹æ³•ã€‚



```python
import hashlib
import base64
from Crypto.Cipher import AES
class  AESCipher(object):
    def __init__(self, key):
        self.bs = AES.block_size
        self.key=hashlib.sha256(AESCipher.str_to_bytes(key)).digest()
    @staticmethod
    def str_to_bytes(data):
        u_type = type(b"".decode('utf8'))
        if isinstance(data, u_type):
            return data.encode('utf8')
        return data
    @staticmethod
    def _unpad(s):
        return s[:-ord(s[len(s) - 1:])]
    def decrypt(self, enc):
        iv = enc[:AES.block_size]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return  self._unpad(cipher.decrypt(enc[AES.block_size:]))
    def decrypt_string(self, enc):
        enc = base64.b64decode(enc)
        return  self.decrypt(enc).decode('utf8')
encrypt = "P37w+VZImNgPEO1RBhJ6RtKl7n6zymIbEG1pReEzghk="
cipher = AESCipher("test key")
print("æ˜æ–‡:\n{}".format(cipher.decrypt_string(encrypt)))
```

- **Java**

```java
package com.larksuite.oapi.sample;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
public class Decrypt {
    public static void main(String[] args) throws Exception {
        Decrypt d = new Decrypt("test key");
        System.out.println(d.decrypt("P37w+VZImNgPEO1RBhJ6RtKl7n6zymIbEG1pReEzghk=")); //hello world
    }
    private byte[] keyBs;
    public Decrypt(String key) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            // won't happen
        }
        keyBs = digest.digest(key.getBytes(StandardCharsets.UTF_8));
    }
    public String decrypt(String base64) throws Exception {
        byte[] decode = Base64.getDecoder().decode(base64);
        Cipher cipher = Cipher.getInstance("AES/CBC/NOPADDING");
        byte[] iv = new byte[16];
        System.arraycopy(decode, 0, iv, 0, 16);
        byte[] data = new byte[decode.length - 16];
        System.arraycopy(decode, 16, data, 0, data.length);
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyBs, "AES"), new IvParameterSpec(iv));
        byte[] r = cipher.doFinal(data);
        if (r.length > 0) {
            int p = r.length - 1;
            for (; p >= 0 && r[p] <= 16; p--) {
            }
            if (p != r.length - 1) {
                byte[] rr = new byte[p + 1];
                System.arraycopy(r, 0, rr, 0, p + 1);
                r = rr;
            }
        }
        return new String(r, StandardCharsets.UTF_8);
    }
}
```

- **Golang**

```go
package main
import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/sha256"
        "encoding/base64"
        "errors"
        "fmt"
        "strings"
)
func main() {
        s, err := Decrypt("P37w+VZImNgPEO1RBhJ6RtKl7n6zymIbEG1pReEzghk=", "test key")
        if err != nil {
                panic(err)
        }
        fmt.Println(s) //hello world
}
func Decrypt(encrypt string, key string) (string, error) {
        buf, err := base64.StdEncoding.DecodeString(encrypt)
        if err != nil {
                return "", fmt.Errorf("base64StdEncode Error[%v]", err)
        }
        if len(buf) < aes.BlockSize {
                return "", errors.New("cipher  too short")
        }
        keyBs := sha256.Sum256([]byte(key))
        block, err := aes.NewCipher(keyBs[:sha256.Size])
        if err != nil {
                return "", fmt.Errorf("AESNewCipher Error[%v]", err)
        }
        iv := buf[:aes.BlockSize]
        buf = buf[aes.BlockSize:]
        // CBC mode always works in whole blocks.
        if len(buf)%aes.BlockSize != 0 {
                return "", errors.New("ciphertext is not a multiple of the block size")
        }
        mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(buf, buf)
        n := strings.Index(string(buf), "{")
        if n == -1 {
                n = 0
        }
        m := strings.LastIndex(string(buf), "}")
        if m == -1 {
                m = len(buf) - 1
        }
        return string(buf[n : m+1]), nil
}
```

- **Node.js**

```javascript
const crypto = require("crypto");
class AESCipher {
    constructor(key) {
        const hash = crypto.createHash('sha256');
        hash.update(key);
        this.key = hash.digest();
    }
    decrypt(encrypt) {
        const encryptBuffer = Buffer.from(encrypt, 'base64');
        const decipher = crypto.createDecipheriv('aes-256-cbc', this.key, encryptBuffer.slice(0, 16));
        let decrypted = decipher.update(encryptBuffer.slice(16).toString('hex'), 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }
}
encrypt = "P37w+VZImNgPEO1RBhJ6RtKl7n6zymIbEG1pReEzghk="
cipher = new AESCipher("test key")
console.log(cipher.decrypt(encrypt))
// hello world
```

- **C#**

```c#
using System;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
namespace decrypt
{
        class AESCipher
        {
                const int BlockSize = 16;
                private byte[] key;
                public AESCipher(string key)
                {
                        this.key = SHA256Hash(key);
                }
                public string DecryptString(string enc)
                {
                        byte[] encBytes = Convert.FromBase64String(enc);
                        RijndaelManaged rijndaelManaged = new RijndaelManaged();
                        rijndaelManaged.Key = this.key;
                        rijndaelManaged.Mode = CipherMode.CBC;
                        rijndaelManaged.IV = encBytes.Take(BlockSize).ToArray();
                        ICryptoTransform transform = rijndaelManaged.CreateDecryptor();
                        byte[] blockBytes = transform.TransformFinalBlock(encBytes, BlockSize, encBytes.Length - BlockSize);
                        return System.Text.Encoding.UTF8.GetString(blockBytes);
                }
                public static byte[] SHA256Hash(string str)
                {
                        byte[] bytes = Encoding.UTF8.GetBytes(str);
                        SHA256 shaManaged = new SHA256Managed();
                        return shaManaged.ComputeHash(bytes);
                }
                public static void Main(string[] args)
                {
                        string encrypt = "P37w+VZImNgPEO1RBhJ6RtKl7n6zymIbEG1pReEzghk=";
                        AESCipher cipher = new AESCipher("test key");
                        Console.WriteLine(cipher.DecryptString(encrypt));
                }
        }
}
```

- **PHP**

```php
<?php
$encrypt_data = ""; // å¾…è§£å¯†çš„ä¿¡æ¯
$encrypt_key = ""; // ä»å¼€å‘è€…åå°è·å– Encrypt Key
$base64_decode_message = base64_decode($encrypt_data);
$iv = substr($base64_decode_message, 0, 16);
$encrypted_event = substr($base64_decode_message, 16);
$decrypt = openssl_decrypt($encrypted_event, 'AES-256-CBC', hash('sha256', $encrypt_key, true), OPENSSL_RAW_DATA, $iv);
print($decrypt); 
// get the real event
```

### å“åº”å›è°ƒè¯·æ±‚

ä½ çš„ä¸šåŠ¡æœåŠ¡å™¨æ¥æ”¶å›è°ƒè¯·æ±‚åï¼Œéœ€è¦åœ¨ 3 ç§’å†…å“åº”å›è°ƒï¼Œä»¥å®Œæˆé£ä¹¦å®¢æˆ·ç«¯ï¼ˆå‰ç«¯ï¼‰çš„äº¤äº’è¡Œä¸ºã€‚ç›®å‰éœ€è¦è®¢é˜…å›è°ƒçš„åŠŸèƒ½ä»¥åŠå¯¹åº”çš„å›è°ƒç»“æ„ã€ä½¿ç”¨æ–¹å¼ç­‰è¯´æ˜å‚è§ä¸‹è¡¨ã€‚

| åŠŸèƒ½ | å›è°ƒç»“æ„ | ç›¸å…³æ–‡æ¡£ |
| --- | --- | --- |
| é“¾æ¥é¢„è§ˆ | å®ç°é“¾æ¥é¢„è§ˆåŠŸèƒ½å¿…é¡»è®¢é˜… æ‹‰å–é“¾æ¥é¢„è§ˆæ•°æ® å›è°ƒï¼Œè¯¥å›è°ƒå¯¹åº”çš„å›è°ƒå‚æ•°ã€å“åº”å‚æ•°è¯´æ˜ï¼Œå¯å‚è§æ‹‰å–é“¾æ¥é¢„è§ˆæ•°æ®ã€‚ | äº†è§£é“¾æ¥é¢„è§ˆåŠŸèƒ½ï¼Œä»¥åŠå¦‚ä½•é…ç½®é“¾æ¥é¢„è§ˆï¼Œå‚è§é“¾æ¥é¢„è§ˆå¼€å‘æŒ‡å—ã€‚ |
| é£ä¹¦å¡ç‰‡ | å¦‚æœä½ æ„å»ºçš„é£ä¹¦å¡ç‰‡å¯é€šè¿‡äº¤äº’ç»„ä»¶å®Œæˆä¸šåŠ¡å¤„ç†ï¼Œåˆ™éœ€è¦è®¢é˜… å¡ç‰‡å›ä¼ äº¤äº’ å›è°ƒï¼Œè¯¥å›è°ƒå¯¹åº”çš„å›è°ƒå‚æ•°ã€å“åº”å‚æ•°è¯´æ˜ï¼Œå¯å‚è§å¡ç‰‡å›ä¼ äº¤äº’ã€‚ | - äº†è§£é£ä¹¦å¡ç‰‡åŠŸèƒ½ï¼Œå‚è§é£ä¹¦å¡ç‰‡æ¦‚è¿°ã€‚<br>- äº†è§£é£ä¹¦å¡ç‰‡è¯·æ±‚å›è°ƒå®ç°æµç¨‹ï¼Œå‚è§é…ç½®å¡ç‰‡äº¤äº’ã€‚ |


